# Automatically generated by Simple_ROS_Configurator
# Simple_ROS_Configurator: !SRC_LINK!
# Generated via !GEN_METHOD!
#
# License: CC BY 4.0
# Get your copy at
# https://creativecommons.org/licenses/by/4.0/

import rclpy
import threading
from rclpy.node import Node

from std_msgs.msg import String

# import and "construct" neccessary types
from typing import TypeVar
MsgType = TypeVar('MsgType')


class _Pub:
    """
    Stores information about the publisher.
    """
    name: str
    msg_type: MsgType
    topic: str
    messages: [MsgType]
    lock: threading.Lock
    stop: bool

    def __init__(self, name: str, msg_type: MsgType, topic: str):
        """
        Init an instance of the Subscription/Publication class _Pub
        :param name: Name for this instance.
        :param msg_type: Type of message to be published / received.
        :param topic: Name of the topic to post / listen to.
        """
        self.name = name
        self.msg_type = msg_type
        self.topic = topic
        self.messages = []
        self.lock = threading.Lock()
        self.stop = False


pubs: [_Pub]


class Publisher(Node):
    pub: _Pub

    def __init__(self, pub: _Pub):
        self.pub = pub
        super().__init__(pub.name)
        self.publisher_ = self.create_publisher(pub.msg_type, pub.topic, 10)
        timer_period = 0.1  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)

    def publish(self, msg: MsgType):
        self.publisher_.publish(msg)

    def timer_callback(self):
        if self.pub.stop:
            exit()

        if len(self.pub.messages) > 0:
            self.pub.lock.acquire()
            msg = self.pub.messages.pop(0)
            self.pub.lock.release()
            self.publish(msg)
            # self.get_logger().info('Publishing: "%s"' % msg.data)



def publish(topic: str, msg: MsgType):
    global pubs
    for p in pubs:
        if p.topic == topic:
            p.lock.acquire()
            p.messages.append(msg)
            p.lock.release()
            return


def startpublisher(pub: _Pub):
    publisher = Publisher(pub)
    rclpy.spin(publisher)
    # Destroy the node explicitly
    # (optional - otherwise it will be done automatically
    # when the garbage collector destroys the node object)
    publisher.destroy_node()


threads: []


def start_publishers(args=None):
    rclpy.init(args=args)

    for pub in pubs:
        t = (threading.Thread(target=startpublisher, args=pub), pub)
        threads.append(t)
        a, b = t
        a.start()


def stop_publishers():
    for t in threads:
        a, b = t
        b.stop = True

    rclpy.shutdown()
