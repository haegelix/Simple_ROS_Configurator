# Automatically generated by Simple_ROS_Configurator
# Simple_ROS_Configurator: !SRC_LINK!
# Generated via !GEN_METHOD!
#
# License: CC BY 4.0
# Get your copy at
# https://creativecommons.org/licenses/by/4.0/

import rclpy
import threading
from rclpy.node import Node
from rclpy.node import Timer

# import and "construct" neccessary types
from typing import TypeVar
# from std_msgs.msg import String

MsgType = TypeVar('MsgType')


class _Pub:
    """
    Stores information about the publisher.
    """
    name: str
    msg_type: MsgType
    topic: str
    messages: [MsgType]
    lock: threading.Lock
    # stop: bool  # maybe not needed
    thread: threading.Thread

    def __init__(self, name: str, msg_type: MsgType, topic: str):
        """
        Init an instance of the Subscription/Publication class _Pub
        :param name: Name for this instance.
        :param msg_type: Type of message to be published / received.
        :param topic: Name of the topic to post / listen to.
        """
        self.name = name
        self.msg_type = msg_type
        self.topic = topic
        self.messages = []
        self.lock = threading.Lock()
        # self.stop = False  # maybe not needed


class Publisher(Node):
    pub: _Pub
    timer: Timer

    def __init__(self, pub: _Pub):
        self.pub = pub
        super().__init__(pub.name)
        self.publisher_ = self.create_publisher(pub.msg_type, pub.topic, 10)
        timer_period = 0.1  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)

    def timer_callback(self):
        # maybe not needed to shut down
        # if self.pub.stop:
        #    self.timer.cancel()
        #    self.timer.destroy()
        #    rclpy.shutdown()

        if len(self.pub.messages) > 0:
            self.pub.lock.acquire()
            msg = self.pub.messages.pop(0)
            self.pub.lock.release()
            self.publisher_.publish(msg)
            # self.get_logger().info('Publishing: "%s"' % msg.data)


p: _Pub


#p = _Pub("test", String, "topic")
# !INSERT_PUBLISHER_DECLARATION_HERE!

def publish(msg: MsgType):
    global p
    p.lock.acquire()
    p.messages.append(msg)
    p.lock.release()
    return


def t_start_publisher(pub: _Pub):
    publisher = Publisher(pub)
    rclpy.spin(publisher)
    # Destroy the node explicitly
    # (optional - otherwise it will be done automatically
    # when the garbage collector destroys the node object)
    publisher.destroy_node()


def start_publisher(args=None):
    rclpy.init(args=args)

    # start the publisher in a separate thread
    p.thread = threading.Thread(target=t_start_publisher, args=(p,))
    p.thread.start()


def stop_publisher():
    # p.stop = True # maybe not needed
    rclpy.shutdown()
    p.thread.join()
